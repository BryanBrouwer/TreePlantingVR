Minimum requirements:
Support for: VR -> Quest 2 / 3 standalone

Seeds:
- Atleast 2 types (will make atleast 3 for ensuring easy support of adding more)
- Seeds should have conditions for planting, like being near other seeds or environmental conditions
- While growing players should perform an action to progress to next stage.
	- If said action is not done in time, then the plant will die.
- There should be 3 stages, seed, sapling, tree.

Game:
- Should have a loop / ending, not unlimited. This through story, area, or time.
- There should be a score component, with the goal of reaching highest score possible.

Notes:
- No grid needed, so will likely go with free placement
- Dont focus on visuals, but it is a plus.
- Focus on player onboarding (maybe a tutorial, or using spatial UI elements to explain all interactions, similar to what I did for Shell)
- Write out decision making process, and explain specific coding choices with comments (Will probably write out the bigger decisions in an attached document)
- Point out the source of assets in a readme.

Initial concept / plan:

- Focus on functionality first, afterwards will spend remaining time on polish and "game design"
- Bare functionality plan:

For seeds likely will use scriptable objects for easy setting and data management.
Initial idea for requirements are:

Conditions and actions:
Using strategy design pattern to add modular actions and conditions for the progression, think of "Distance from X type" condition
This could either be a singular scriptable object type for distance, for both being near and far away similar to my nodes for unreal engine state tree.
However since conditional UI is not a pre-existing feature in unity, might be better for speed to stick with 2 seperate Scriptable objects.

Condition:
- Scriptable object
- Function that returns the result of the condition


For actions it can work similar:
- Scriptable object to manage rules and functionality
- Function that sets up any required world state for the action to be completed
- Add any needed asset references to the scriptable objects.
Design wise:
I want to use a spatial UI element above / next to (depending on growth stage) the tree, which indicates an icon of the desired interaction.
The background of the UI element would switch between 3 stages: White, Orange, Red depending on how much time is remaining before death.
Current ideas for interactions are:
- Watering
- Removing weeds
- Cutting redundant branches (Will probably skip this, since 2 are already enough, this could be future content for full grown tree maintenance)
For the action deadline loop:
- Look into using a coroutine and yielding it till the next UI update checkpoint, 
	this so it doesnt run every frame, or look into object reduced tick rate.
- Stop the coroutine upon action completion
- If not stopped before final stage, transition plant to next stage:

Growth stages:
- Enum
- Seed, Sapling, Tree, Dead

Seed types:
- Scriptable object
Dictionary for each enum element of growth stage:
- Actions to grow
- Visual asset
- Next stage
Planting conditions:
- Array of the Condition scriptable object
Additional Info:
(For dynamic UI like tutorial or onboarding / shop etc)
- Icon
- Description

Planting:
When holding the seeds close enough to the ground, instantiate a transparent preview mesh, colored green or red depending on plantable condition.
- Later polish, add a context UI displaying why its not plantable, otherwise rely on a simple board the contains a written explanation of each seed type.

Score:
- Will be awarded on each "state" transition with increasing amounts
- A plant dying will reduce some score as a consequence
- Why so often? Providing more often in smaller amounts will indicate to players they are performing correctly.

The tools to complete the action could utilize an interface to indicate they are tools, and for checking what kind of action it solves.
Also for this use the tag system for collision layers




--- Progress update:
- Currently Ive got support for seed types, planting condtions, growth actions
- Also support for plant instances, growing into new stages, and timeouts with dead.
- Got all relevant hooks ready for adding UX into the game.
- Planting conditions still lack actual functional condition checks, 
	I will add a PlantInstanceManager to keep track of a dictionary per "plantType"
	This way when looping over for conditions I dont need to do an extra expensive call to get gameobjects with components and still filter on plantType.
	
Additionally there is currently a bug with the placeholder watering can that only works when tilting right, probably since the objects forward vector isnt in the direction that is expected.

I also still need simple art assets
And I need to make a few material instances since I want to implement the material plant condition as well.
Need to still add a score manager to keep track of the score, and display it on a UI.
And still need a system that limits the players session length in any manner.
Also need a system that provides more seeds to the player.

For now for the idea is a simple table with the different seed types.
I can make a simple seed giver class, which you link a seed scriptable object to which will then generate the seed objects whenever being picked up
Additionally will add another component to the seed that tracks if its still being held, other destroy it after X seconds, to avoid players grabbing infinite seeds and increase object count.

PlantInstanceManager and for ScoreManager I am thinking of utlizing singletons for easier access and management.

For limiting the session length I will likely just add a timer of 10 minutes per session. When done play a sound effect to get the players attention back to the stand and showcase the final score. 
With a button to try again. This way you dont confuse the player with random teleports or unexpected UI popups.
But I might need to look into more guidance back to the board.


-- Assets used:
Kenney - Nature Kit
https://kenney.nl/assets/nature-kit

Kenny - Survival Kit
https://kenney.nl/assets/survival-kit

Watering Can by Mekon Polygons
https://sketchfab.com/3d-models/watering-can-c24d4602e52544feaa37f23c7bd695f9

Garden tool by re1monsen
https://sketchfab.com/3d-models/garden-tool-96c09a1004764af6abdce344d3c6740b

Low Poly Sacks by Amigo 3D
https://www.cgtrader.com/free-3d-models/food/miscellaneous/low-poly-sacks

Water droplet png
<a href='https://pngtree.com/freepng/water-drop-reflection_21239844.html'>png image from pngtree.com/</a>

Trowel PNG
<a href='https://pngtree.com/freepng/garden-hoe_20426061.html'>png image from pngtree.com/</a>

Currently the only things remaining from my plans would be the weeding growth action and a demo scene
For the weeding action I need to make the Trowel tool and a weeding action, then assign it to some trees their steps.
For this action I will spawn an additional mesh to represent weeds, which gets removed upon completion.

Currently, I have the full demo done, and I am quite happy with it, especially from a feature completeness point of view.
Known improvement areas are:
- Another pass on the scripts to see which areas can be cleaned up, since at the end, some aspects were a bit more rushed for the balance of time.
- The action UI indicators are currently stuck in 1 place, depending on each stage, their provided offset. However, it would be nicer if they moved around the tree to always face the direction of the player. This could be done quite easily by adding an update hook in the plant and then calculating the direction towards the player.
- Additionally, I would have liked to implement a backpack or respawn point for the tools, since you could intentionally get them out of the map, or not see them clearly if you drop them next to trees. However, I ended up spending that time refining other aspects of the demo.
- The lighting setup could use a big improvement.
- More interesting rules or actions.
- An actual shop or other method of getting seeds for game design reasons.
- I originally had some plans to incorporate Localization, but this, however, would have cost much more time than I have available. So I ended up doing English support by default.
